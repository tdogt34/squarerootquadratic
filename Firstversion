// This one organizes by |x-xo| where xo is vertex x coordinate
#include <stdlib.h>
#include <stdio.h>
#include <cs50.h>
#include <math.h>
#include <time.h>

int main(void)
{
    // printf("Program for inspecting y=sqrt(a^2 x^2+bx+c) for all integer pairs (x,y).\n");
    // printf("It is known that y is only an integer when x = (n^2-c)/(b-2an) where n is an integer.\n");
    // printf("Checking for all integer n within absolute distance MAX from n=b/2a for MAX<=100000000 and MAX != 0\n");
    // printf("The number of solutions output by this program is the number of ordered integer pairs (x,y).\n");
    // printf("Do you want a more detailed explanation? (1=yes, 0=no): ");
    // info = GetInt();
    // if (info = 1)
    // {
    //     printf("LINK");
    // }
    int loop = 1;
    // int info = 0;
    while (loop == 1)
    {
        printf("Enter values for a,b,c for equation y=sqrt(a^2 x^2+bx+c)\n");
        printf("Please make sure the radical is in simpliest terms (gcd(a^2,b,c)â‰ k^2 for any natural number k>1)\n");
        printf("If the radical is not in simplest terms this program will print all values of y but may not print all x)\n");
        printf("a= ");
        long double o = GetLongLong();
        // using o here as dummy variable, take absolute value on next line for value of a
        while (o == 0)
        {
            printf("a can not be 0, try again\n");
            printf("a= ");
            o = GetLongLong();
        }
        long double a = fabsl(o);
        long long A = roundl(a) * roundl(a);
        printf("b= ");
        long double b = GetLongLong();
        long long B = roundl(b);
        printf("c= ");
        long double c = GetLongLong();
        long long C = roundl(c);
        // all above gets info for funciton
        // if statement and function ensure not every number is printed
        if (fabsl(b) == 2 * a * sqrtl(fabsl(c)) && c >= 0)
        {
            printf("There are infinitely many integer solutions, restarting \n\n");
        }
        if (fabsl(b) != 2 * a * sqrtl(fabsl(c)))
        {
            int c_loop = 1;
            int big_c_loop = 0;
            if (c> 2500000000000000)
            {
                big_c_loop = 1;
            }
            while (big_c_loop == 1)
            {
                c_loop = 1;
                while (c_loop == 1)
                {
                    long double times =  c / 625000000000000;
                    printf("\nThis value of c is very large and will probably take at least %Lf seconds to process.\n", times);
                    printf("Continue with current c or try a another c? (0=continue, 1=try another c): ");
                    int new_range = GetInt();
                    if (new_range == 1)
                    {
                        printf("c= ");
                        c = GetLongLong();
                        c_loop = 0;
                        big_c_loop = 0;
                        if (c > 2500000000000000)
                        {
                            big_c_loop = 1;
                        }
                    }
                    if (new_range == 0)
                    {
                        big_c_loop = 0;
                        c_loop = 0;
                    }
                }
            }
            // makes sure computer doesn't run too long
            printf("checking sqrt(%llix^2+%llix+%lli) for integer pairs (x,y)\n", A, B, C);
            printf("Would you like to have all solutions printed? (0=no 1=yes):");
            int print = GetInt();
            printf("\n");
            long double n = b / (2 * a);
            long long n_1 = 0;
            long long n_2 = 1;
            // Both solutions for n given x
            long long n_4 = 0;
            long long n_5 = 0;
            // Both solutions for n given x_2 (only if a = 1)
            long double x = 0.1;
            // x value for funciton
            long long x_2 = 0;
            // Second solution for x given y (both x's exist if and only if a = 1)
            long long y = 0;
            // y value of funciton
            long long nsub = 2;
            // just for making computations every so slightly faster
            float total_number = 0;
            int offset = 0;
            if (roundl(n) == n)
            // If the two are equal the offset ensures no division by 0 at asymptote.
            {
                offset = 1;
            }
            long long newnu = ceill(n);
            // upper n value nearest asymptote for integer value generating function for x
            long long newnl = floorl(n);
            // lower n value neareste asymptote for integer value generating function for x
            long long roundx = 1;
            int length = floorl(log10l(fabsl(c))) + 2;
            // max length of any number output, this is for organization purposes later
            int lengthy = 2;
            // length of y
            int digity = 1;
            // makes lengthy compatible with mod function
            long long total = 2;
// ----------------------------------------------------------------------------------------- below: b/a^2 != int, c > 0
            if (c > 0 && fabsl(b) < 2 * a * sqrtl(fabsl(c)) && b / (a * a) != roundl(b / (a * a)))
            {
                long long lower_c = ceill((b - sqrtl(4 * a * a * c - b * b)) / (2 * a));
                long long upper_c = floorl((b + sqrtl(4 * a * a * c - b * b)) / (2 * a));
                // upper and lower here represent the minimal distance between the left and right halves of the curve.
                for (long long counter = offset; counter <= newnl - lower_c; counter = counter + 1)
                // counter value info, prints lower solutions for x in increasing order x
                {
                    nsub = newnl - counter;
                    x = (nsub * nsub - c) / (b - 2 * a * nsub);
                    // solves right to left for integer values of x between vertical asymptote x(n) and lower_c.
                    if (x == roundl(x))
                    {
                        total_number++;
                        if (print == 1)
                        {   
                            y = roundl(a * x + nsub);
                            // increases total number of solution count by 1
                            roundx = roundl(x);
                            // makes output pretty integer
                            n_1 = nsub;
                            // lower value of n when solution put out, this is just for making the code easier to read
                            n_2 = roundl(- 2 * a * x - n_1);
                            // upper value of n when solution put out
                            
                            printf("n= %lli, %lli\n", n_1, n_2);
                            
                            printf("\033[1;32m");
                            printf("x= %lli\n", roundx);
                            printf("\033[0m");
                            
                            y = llabs(y);
                            printf("\033[1;31m");
                            printf("y= %lli\n\n", y);
                            printf("\033[0m");
                            // First line of trio: following is color, bkgrnd color, font, text color.
                            // Second line of trio: output text.
                            // Third line of trio: end text style sequence (between m is what is colored).
                        }
                    }
                }
                for (long long counter = 0; counter <= upper_c - newnu - offset; counter = counter + 1)
                // counter value info, prints upper solutions for x in increasing order x
                {
                    nsub = upper_c - counter;
                    x = (nsub * nsub - c) / (b - 2 * a * nsub);
                    // solves right to left for integer values of x between upper_c and vertical asymptote x(n).
                    if (x == roundl(x))
                    {
                        total_number++;
                        if (print == 1)
                        {
                            y = roundl(a * x + nsub);
                            // increases total number of solution count by 1
                            roundx = roundl(x);
                            // makes output pretty integer
                            n_1 = nsub;
                            // upper value of n when solution put out
                            n_2 = roundl(- 2 * a * x - n_1);
                            // lower value of n when solution put out
                            printf("n= %lli, %lli\n", n_2, n_1);
                            
                            printf("\033[1;32m");
                            printf("x= %lli\n", roundx);
                            printf("\033[0m");
                            
                            y = llabs(y);
                            printf("\033[1;31m");
                            printf("y= %lli\n\n", y);
                            printf("\033[0m");
                            // First line of trio: following is color, bkgrnd color, font, text color.
                            // Second line of trio: output text.
                            // Third line of trio: end text style sequence (between m is what is colored).
                        }
                    }
                }
            }
// ----------------------------------------------------------------------------------------- below: b/a^2 == int, c > 0
            if (c > 0 && fabsl(b) < 2 * sqrtl(fabsl(c)) && b / (a * a) == roundl(b / (a * a)))
            {
                long long lower_c = ceill((b - sqrtl(4 * a * a * c - b * b)) / (2 * a));
                long long upper_c = floorl((b + sqrtl(4 * a * a * c - b * b)) / (2 * a));
                // minimum distance between solutions n for given x. d/dx (n_1(x) - n_2(x))=0
                if (llabs(upper_c - newnu) >= llabs(newnl - lower_c)) 
                {
                    for (long long counter = 0; counter <= newnl - lower_c - offset; counter = counter + 1)
                    // counter value info, prints lower solutions for x in increasing order x
                    {
                        nsub = lower_c + counter;
                        x = (nsub * nsub - c) / (b - 2 * a * nsub);
                        // solves left to right for integer values of x between lower_c and vertical asymptote x(n).
                        if (x == roundl(x))
                        {
                            total_number++;
                            if (print == 1)
                            {
                                y = roundl(a * x + nsub);
                                // increases total number of solution count by 1
                                roundx = roundl(x);
                                // makes output pretty integer
                                n_1 = nsub;
                                // lower value of n when solution put out, this is just for making the code easier to read
                                n_2 = roundl(- 2 * a * x - n_1);
                                // upper value of n when solution put out
                                x_2 = roundl(- b / (a * a) - x);
                                // lower value of x
                                n_4 = roundl(b / a - n_2);
                                // smaller of two, for full explanation, see bottom
                                n_5 = roundl(b / a - n_1);
                                // larger of two for full explanation, see bottom
                                digity = roundl(floorl(log10(llabs(y))) + 1);
                                if (digity%2 == 1)
                                {
                                    lengthy = 4 + 2 * length + floorl((log10(llabs(y)) + 1)/ 2);
                                }
                                if (digity%2 == 0)
                                {
                                    lengthy = 4 + 2 * length + roundl((floorl(log10(llabs(y))) + 1)/ 2);
                                }
                                printf("n=%*lli, %*lli ||%*lli,%*lli\n", length, n_1, length, n_2, length, n_4, length, n_5);
                                
                                printf("\033[1;32m");
                                printf("x= %*c %*lli ||%*lli\n", length, ' ', length, roundx, length, x_2);
                                printf("\033[0m");
                                
                                y = llabs(y);
                                printf("\033[1;31m");
                                printf("y=%*lli\n\n", lengthy, y);
                                printf("\033[0m");
                                // First line of trio: following is color, bkgrnd color, font, text color.
                                // Second line of trio: output text.
                                // Third line of trio: end text style sequence (between m is what is colored).
                            }
                        }
                    }
                }
                if (llabs(upper_c - newnu) < llabs(newnl - lower_c))
                {
                    for (long long counter = 0; counter <= upper_c - newnu - offset; counter = counter + 1)
                    // counter value info, prints upper solutions for x in increasing order x
                    {
                        nsub = upper_c - counter;
                        x = (nsub * nsub - c) / (b - 2 * a * nsub);
                        // solves right to left for integer values of x between upper_c and vertical asymptote x(n).
                        if (x == roundl(x))
                        {
                            total_number++;
                            if (print == 1)
                            {
                                y = roundl(a * x + nsub);
                                // increases total number of solution count by 1
                                roundx = roundl(x);
                                // makes output pretty integer
                                n_1 = nsub;
                                // upper value of n when solution put out, this is just for making the code easier to read
                                n_2 = roundl(- 2 * a * x - n_1);
                                // lower value of n when solution put out
                                x_2 = roundl(- b / (a * a) - x);
                                // lower value of x
                                n_4 = roundl(b / a - n_1);
                                // smaller of two, for full explanation, see bottom
                                n_5 = roundl(b / a - n_2);
                                // smaller of two, for full explanation, see bottom
                                digity = roundl(floorl(log10(llabs(y))) + 1);
                                if (digity%2 == 1)
                                {
                                    lengthy = 4 + 2 * length + floorl((log10(llabs(y)) + 1)/ 2);;
                                }
                                if (digity%2 == 0)
                                {
                                    lengthy = 4 + 2 * length + roundl((floorl(log10(llabs(y))) + 1)/ 2);
                                }
                                printf("n=%*lli, %*lli ||%*lli,%*lli\n", length, n_4, length, n_5, length, n_2, length, n_1);
                                
                                printf("\033[1;32m");
                                printf("x= %*c %*lli ||%*lli\n", length, ' ', length, x_2, length, roundx);
                                printf("\033[0m");
                                
                                y = llabs(y);
                                printf("\033[1;31m");
                                printf("y=%*lli\n\n", lengthy, y);
                                printf("\033[0m");
                                // First line of trio: following is color, bkgrnd color, font, text color.
                                // Second line of trio: output text.
                                // Third line of trio: end text style sequence (between m is what is colored).
                            }
                        }
                    }
                }
            }
// ------------------------------------------------------------------------------------------ below: b/a^2 != int, c < 0
// EVERYTHING BELOW BUT ABOVE NEXT COMMENT IS SAME CONCEPT AS ABOVE BUT IF C<0
            if ((c <= 0 || fabsl(b) > 2 * a * sqrtl(fabsl(c))) && b / (a * a) != roundl(b / (a * a)))
            {
                long long upper_c = ceill((b + sqrt(b * b - 4 * a * a * c))/(2 * a));
                long long lower_c = floorl((b - sqrt(b * b - 4 * a * a * c))/(2 * a));
                // d/dn x(n) = 0, solutions for n as above, max and min of function
                for (long long counter = offset; counter <= upper_c - newnu; counter = counter + 1)
                // counter value info, prints lower solutions for x in increasing order x
                {
                    nsub = newnu + counter;
                    x = (nsub * nsub - c) / (b - 2 * a * nsub);
                    // solves left to right for lower values of x between vertical asymptote and right local max of x(n).
                    if (x == roundl(x))
                    {
                        total_number++;
                        if (print == 1)
                        {
                            y = roundl(a * x + nsub);
                            // increases total number of solution count by 1
                            roundx = roundl(x);
                            // makes output pretty integer
                            n_1 = nsub;
                            // lower value of n when solution put out
                            n_2 = roundl(- 2 * a * x - n_1);
                            // upper value of n when solution put out
                            printf("n= %lli, %lli\n", n_1, n_2);
                            
                            printf("\033[1;32m");
                            printf("x= %lli\n", roundx);
                            printf("\033[0m");
                            
                            y = llabs(y);
                            printf("\033[1;31m");
                            printf("y= %lli\n\n", y);
                            printf("\033[0m");
                            // First line of trio: following is color, bkgrnd color, font, text color.
                            // Second line of trio: output text.
                            // Third line of trio: end text style sequence (between m is what is colored).
                        }
                    }
                }
                for (long long counter = 0; counter <= newnl - lower_c - offset; counter = counter + 1)
                // counter value info, prints upper solutions for x in increasing order x
                {
                    nsub = lower_c + counter;
                    x = (nsub * nsub - c) / (b - 2 * a * nsub);
                    // solves left to right for upper values of x between left local min and vertical asymptote of x(n).
                    if (x == roundl(x))
                    {
                        total_number++;
                        if (print == 1)
                        {
                            y = roundl(a * x + nsub);
                            // increases total number of solution count by 1
                            roundx = roundl(x);
                            // makes output pretty integer
                            n_1 = nsub;
                            // upper value of n when solution put out, this is just for making the code easier to read
                            n_2 = - 2 * a * x - n_1;
                            // lower value of n when solution put out
                            printf("n= %lli, %lli\n", n_2, n_1);
                            
                            printf("\033[1;32m");
                            printf("x= %lli\n", roundx);
                            printf("\033[0m");
                            
                            y = llabs(y);
                            printf("\033[1;31m");
                            printf("y= %lli\n\n", y);
                            printf("\033[0m");
                            // First line of trio: following is color, bkgrnd color, font, text color.
                            // Second line of trio: output text.
                            // Third line of trio: end text style sequence (between m is what is colored).
                        }
                    }
                }
            }
// ------------------------------------------------------------------------------------------ below: b/a^2 == int, c < 0
            if ((c <= 0 || fabsl(b) > 2 * sqrtl(fabsl(c))) && b / (a * a) == roundl(b / (a * a)))
            {
                long long upper_c = ceill((b + sqrt(b * b - 4 * a * a * c))/(2 * a));
                long long lower_c = floorl((b - sqrt(b * b - 4 * a * a * c))/(2 * a));
                if (llabs(upper_c - newnu) >= llabs(newnl - lower_c)) 
                {
                    for (long long counter = 0; counter <= newnl - lower_c - offset; counter = counter + 1)
                    // counter value info, prints upper solutions for x in increasing order x
                    {
                        nsub = lower_c + counter;
                        x = (nsub * nsub - c) / (b - 2 * a * nsub);
                        // solves left to right for upper integer values of x between left local min and asymptote of x(n).
                        if (x == roundl(x))
                        {
                            total_number++;
                            if (print == 1)
                            {
                                y = roundl(a * x + nsub);
                                // increases total number of solution count by 1
                                roundx = roundl(x);
                                // makes output pretty integer
                                n_1 = nsub;
                                // upper value of n when solution put out, this is just for making the code easier to read
                                n_2 = roundl(- 2 * a * x - n_1);
                                // lower value of n when solution put out
                                x_2 = roundl(- b /(a * a) - x);
                                // lower value of x
                                n_4 = roundl(b / a - n_1);
                                // smaller of two, for full explanation, see bottom
                                n_5 = roundl(b /a - n_2);
                                // smaller of two, for full explanation, see bottom
                                digity = roundl(floorl(log10(llabs(y))) + 1);
                                if (digity%2 == 1)
                                {
                                    lengthy = 4 + 2 * length + floorl((log10(llabs(y)) + 1)/ 2);
                                }
                                if (digity%2 == 0)
                                {
                                    lengthy = 4 + 2 * length + roundl((floorl(log10(llabs(y))) + 1)/ 2);
                                }
                                printf("n=%*lli, %*lli ||%*lli,%*lli\n", length, n_4, length, n_5, length, n_2, length, n_1);
                                
                                printf("\033[1;32m");
                                printf("x= %*c %*lli ||%*lli\n", length, ' ', length, x_2, length, roundx);
                                printf("\033[0m");
                                
                                y = llabs(y);
                                printf("\033[1;31m");
                                printf("y=%*lli\n\n", lengthy, y);
                                printf("\033[0m");
                                // First line of trio: following is color, bkgrnd color, font, text color.
                                // Second line of trio: output text.
                                // Third line of trio: end text style sequence (between m is what is colored).
                            }
                        }
                    }
                }
                if (llabs(upper_c - newnu) < llabs(newnl - lower_c))
                {
                    for (long long counter = 0; counter <= upper_c - newnu - offset; counter = counter + 1)
                    // counter value info, prints lower solutions for x in increasing order x
                    {
                        nsub = upper_c - counter;
                        x = (nsub * nsub - c) / (b - 2 * a * nsub);
                        // solves right to left for lower values of x between right local max and vertical asymptote of x(n).
                        if (x == roundl(x))
                        {
                            total_number++;
                            if (print == 1)
                            {
                                y = roundl(a * x + nsub);
                                // increases total number of solution count by 1
                                roundx = roundl(x);
                                // makes output pretty integer
                                n_1 = nsub;
                                // upper value of n when solution put out, this is just for making the code easier to read
                                n_2 = roundl(- 2 * a * x - n_1);
                                // lower value of n when solution put out
                                x_2 = roundl(- b / (a * a) - x);
                                // lower value of x
                                n_4 = roundl(b / a - n_2);
                                // smaller of two, for full explanation, see bottom
                                n_5 = roundl(b / a - n_1);
                                // smaller of two, for full explanation, see bottom
                                digity = roundl(floorl(log10(llabs(y))) + 1);
                                if (digity%2 == 1)
                                {
                                    lengthy = 4 + 2 * length + floorl((log10(llabs(y)) + 1)/ 2);
                                }
                                if (digity%2 == 0)
                                {
                                    lengthy = 4 + 2 * length + roundl((floorl(log10(llabs(y))) + 1)/ 2);
                                }
                                printf("n=%*lli, %*lli ||%*lli,%*lli\n", length, n_1, length, n_2, length, n_4, length, n_5);
                                
                                printf("\033[1;32m");
                                printf("x= %*c %*lli ||%*lli\n", length, ' ', length, roundx, length, x_2);
                                printf("\033[0m");
                                
                                y = llabs(y);
                                printf("\033[1;31m");
                                printf("y=%*lli\n\n", lengthy, y);
                                printf("\033[0m");
                                // First line of trio: following is color, bkgrnd color, font, text color.
                                // Second line of trio: output text.
                                // Third line of trio: end text style sequence (between m is what is colored).
                            }
                        }
                    }
                }
            }
// EVERYTHING ABOVE BUT BELOW PREVIOUS COMMENT IS THE SAME CONCEPT AS THE FIRST HALF OF THE CODE BUT FOR C<0
            if (total_number == 0)
            {
                printf("No integer solution pairs exist for this function.\n");
                printf("Try another function? (0 = NO; 1 = Try another function): ");
                loop = GetInt();
            }
            if (total_number != 0)
            {
                total = roundl(total_number);
                printf("There are %lli integer solution pairs\n", total);
                printf("Try another function? (0 = NO; 1 = Try another function): ");
                loop = GetInt();
            }
        }
    }
}

// explanation for line 218 and similar lines
//  -b/a^2 = x+x_2
//       y = a*x+n_1
//      -y = a*x+n_2
//       y = a*x_2+n_4
//      -y = a*x_2+n_5
//   -2a*x = n_1+n_2
// -2a*x_2 = n_4+n_5
// solving equations above gives n_2+n_4=n_5+n_1
